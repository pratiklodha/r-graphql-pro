type AbstractModifiedResidue {
  alteredAminoAcidFragment: String
  coordinate: Int
  dbId: ID!
  displayName: String
  endPositionInReferenceSequence: Int
  schemaClass: String
  secondCoordinate: Int
  startPositionInReferenceSequence: Int
}

type Affiliation {
  address: String
  dbId: Int!
  displayName: String!
  name: [String]!
  schemaClass: String!
}

type BlackBoxEvent {
  dbId: Int!
  displayName: String!
  isChimeric: Boolean
  isInDisease: Boolean!
  isInferred: Boolean!
  name: [String]!
  oldStId: String
  releaseDate: String!
  releaseStatus: String
  schemaClass: String!
  speciesName: String!
  stId: String!
  stIdVersion: String!
  systematicName: String
}

type Book {
  ISBN: String
  chapterTitle: String
  dbId: ID!
  displayName: String!
  pages: String
  schemaClass: String!
  title: String!
  year: Int!
}

type CandidateSet {
  dbId: Int!
  definition: String
  displayName: String!
  isInDisease: Boolean!
  isOrdered: Boolean
  name: [String]!
  oldStId: String
  schemaClass: String!
  speciesName: String
  stId: String!
  stIdVersion: String!
  systematicName: String
}

type CatalystActivity {
  dbId: ID!
  displayName: String!
  schemaClass: String!
}

type CatalystActivityReference {
  dbId: ID!
  displayName: String!
  schemaClass: String!
}

type ChemicalDrug {
  dbId: ID!
  displayName: String!
  isInDisease: Boolean!
  name: [String]!
  oldStId: String
  schemaClass: String!
  stId: String!
  stIdVersion: String!
}

type Compartment {
  accession: String!
  databaseName: String!
  dbId: ID!
  definition: String!
  displayName: String!
  name: String!
  schemaClass: String!
  url: String!
}

type Complex {
  dbId: ID!
  displayName: String!
  isChimeric: Boolean
  isInDisease: Boolean!
  name: [String]!
  oldStId: String
  schemaClass: String!
  speciesName: String
  stId: String!
  stIdVersion: String!
  stoichiometryKnown: Boolean
  systematicName: String
}

type ControlReference {
  dbId: ID!
  displayName: String!
  schemaClass: String!
}

type CrosslinkedResidue {
  coordinate: Int
  dbId: ID!
  displayName: String!
  schemaClass: String!
  secondCoordinate: Int
}

type DBInfo {
  checksum: Int!
  name: String!
  version: Int!
}

type DatabaseIdentifier {
  databaseName: String!
  dbId: ID!
  displayName: String!
  identifier: String!
  schemaClass: String!
  url: String!
}

type DatabaseObject {
  dbId: ID!
  abbreviation: String
  accession: String
  accessUrl: String
  address: String
  alteredAminoAcidFragment: String
  approvalSource: [String]
  approved: Boolean
  chain: [String]
  chapterTitle: String
  checksum: Int
  comment: String
  coordinate: Int
  databaseName: String
  dateTime: String
  definition: String
  description: String
  diagramHeight: Int
  diagramWidth: Int
  displayName: String
  doi: String
  ecNumber: String
  endCoordinate: Int
  endPositionInReferenceSequence: Int
  firstname: String
  formula: String
  geneName: String
  hasDiagram: Boolean
  hasEHLD: Boolean
  identifier: String
  initial: String
  inn: String
  ISBN: String
  isChimeric: Boolean
  isInDisease: Boolean
  isInferred: Boolean
  isOrdered: Boolean
  isSequenceChanged: Boolean
  journal: String
  keyword: [String]
  label: String
  maxUnitCount: Int
  minUnitCount: Int
  name: String
  note: String
  oldStId: String
  orcidId: String
  otherIdentifier: [String]
  pages: String
  project: String
  pubmed: [String]
  pubMedIdentifier: Int
  referenceType: String
  releaseDate: String
  releaseStatus: String
  schemaClass: String
  score: Float
  secondaryIdentifier: [String]
  secondCoordinate: Int
  sequenceLength: Int
  speciesName: String
  startCoordinate: Int
  startPositionInReferenceSequence: Int
  stId: String
  stIdVersion: String
  stoichiometryKnown: Boolean
  surname: String
  synonym: [String]
  systematicName: String
  taxId: String
  text: String
  title: String
  trivial: Boolean
  type: String
  uniformResourceLocator: String
  url: String
  variantIdentifier: String
  volume: Int
  year: Int
}

type DefinedSet {
  dbId: ID!
  displayName: String!
  isInDisease: Boolean!
  isOrdered: Boolean
  name: [String]!
  oldStId: String
  schemaClass: String!
  speciesName: String
  stId: String!
  stIdVersion: String!
  systematicName: String
}

type Depolymerisation {
  dbId: ID!
  displayName: String!
  isChimeric: Boolean
  isInDisease: Boolean!
  isInferred: Boolean!
  name: [String]!
  oldStId: String
  releaseDate: String!
  schemaClass: String!
  speciesName: String!
  stId: String!
  stIdVersion: String!
}

type Disease {
  databaseName: String!
  dbId: ID!
  definition: String
  displayName: String!
  identifier: String!
  name: [String]!
  schemaClass: String!
  synonym: [String]
  url: String!
}

type Drug {
  dbId: ID!
  definition: String
  displayName: String
  isInDisease: Boolean
  name: [String]
  oldStId: String
  schemaClass: String
  stId: String
  stIdVersion: String
}

type EntityFunctionalStatus {
  dbId: ID!
  displayName: String!
  schemaClass: String!
}

type EntitySet {
  dbId: Int!
  definition: String
  displayName: String!
  isInDisease: Boolean!
  isOrdered: Boolean
  name: [String]!
  oldStId: String
  schemaClass: String!
  speciesName: String
  stId: String!
  stIdVersion: String!
  systematicName: String
}

type EntityWithAccessionedSequence {
  dbId: ID!
  definition: String
  displayName: String!
  endCoordinate: Int
  isInDisease: Boolean!
  name: [String]!
  oldStId: String
  referenceType: String!
  schemaClass: String!
  speciesName: String!
  stId: String!
  stIdVersion: String!
  startCoordinate: Int
}

type Event {
  dbId: ID!
  schemaClass: String
  oldStId: String
  isInDisease: Boolean
  releaseDate: String
  displayName: String
  stId: String
  speciesName: String
  diagramHeight: Int
  hasEHLD: Boolean
  stIdVersion: String
  releaseStatus: String
  name: String
  definition: String
  hasDiagram: Boolean
  isInferred: Boolean
  doi: String
  diagramWidth: Int
  isChimeric: Boolean
  systematicName: String
}

type EvidenceType {
  dbId: ID!
  displayName: String!
  schemaClass: String!
}

type ExternalOntology {
  databaseName: String!
  dbId: ID!
  definition: String
  displayName: String!
  identifier: String!
  label: String
  name: [String]!
  schemaClass: String!
  synonym: [String]
  url: String!
}

type FailedReaction {
  dbId: ID!
  displayName: String!
  isChimeric: Boolean
  isInDisease: Boolean!
  isInferred: Boolean!
  name: [String]!
  oldStId: String
  releaseDate: String!
  releaseStatus: String
  schemaClass: String!
  speciesName: String!
  stId: String!
  stIdVersion: String!
  systematicName: String
}

type Figure {
  dbId: ID!
  displayName: String!
  schemaClass: String!
  url: String!
}

type FragmentDeletionModification {
  dbId: ID!
  displayName: String!
  endPositionInReferenceSequence: Int!
  schemaClass: String!
  startPositionInReferenceSequence: Int!
}

type FragmentInsertionModification {
  coordinate: Int
  dbId: ID!
  displayName: String!
  endPositionInReferenceSequence: Int!
  schemaClass: String!
  startPositionInReferenceSequence: Int!
}

type FragmentModification {
  alteredAminoAcidFragment: String
  coordinate: Int
  dbId: ID!
  displayName: String
  endPositionInReferenceSequence: Int
  schemaClass: String
  startPositionInReferenceSequence: Int
}

type FragmentReplacedModification {
  alteredAminoAcidFragment: String
  dbId: ID!
  displayName: String!
  endPositionInReferenceSequence: Int!
  schemaClass: String!
  startPositionInReferenceSequence: Int!
}

type FunctionalStatus {
  dbId: ID!
  displayName: String!
  schemaClass: String!
}

type FunctionalStatusType {
  dbId: ID!
  displayName: String!
  name: [String]!
  schemaClass: String!
}

type GO_BiologicalProcess {
  accession: String!
  databaseName: String!
  dbId: ID!
  definition: String!
  displayName: String!
  name: String!
  schemaClass: String!
  url: String!
}

type GO_CellularComponent {
  accession: String!
  databaseName: String!
  dbId: ID!
  definition: String!
  displayName: String!
  name: String!
  schemaClass: String!
  url: String!
}

type GO_MolecularFunction {
  accession: String!
  databaseName: String!
  dbId: ID!
  definition: String!
  displayName: String!
  ecNumber: String
  name: String!
  schemaClass: String!
  url: String!
}

type GO_Term {
  accession: String!
  databaseName: String!
  dbId: ID!
  definition: String!
  displayName: String!
  ecNumber: String
  name: String!
  schemaClass: String!
  url: String!
}

type GeneticallyModifiedResidue {
  alteredAminoAcidFragment: String
  coordinate: Int!
  dbId: ID!
  displayName: String!
  endPositionInReferenceSequence: Int!
  schemaClass: String!
  startPositionInReferenceSequence: Int!
}

type GenomeEncodedEntity {
  dbId: ID!
  definition: String
  displayName: String!
  endCoordinate: Int
  isInDisease: Boolean!
  name: [String]!
  oldStId: String
  referenceType: String!
  schemaClass: String!
  speciesName: String!
  stId: String!
  stIdVersion: String!
  startCoordinate: Int
}

type GroupModifiedResidue {
  coordinate: Int
  dbId: ID!
  displayName: String!
  schemaClass: String!
}

type InstanceEdit {
  dateTime: String!
  dbId: ID!
  displayName: String!
  note: String
  schemaClass: String!
}

type InterChainCrosslinkedResidue {
  coordinate: Int
  dbId: ID!
  displayName: String!
  schemaClass: String!
  secondCoordinate: Int
}

type Interaction {
  accession: [String]!
  databaseName: String!
  dbId: ID!
  displayName: String!
  pubmed: [String]
  schemaClass: String!
  score: Float!
  url: String!
}

type IntraChainCrosslinkedResidue {
  coordinate: Int!
  dbId: ID!
  displayName: String!
  schemaClass: String!
  secondCoordinate: Int
}

type LiteratureReference {
  dbId: ID!
  displayName: String!
  journal: String!
  pages: String
  pubMedIdentifier: Int
  schemaClass: String!
  title: String!
  volume: Int
  year: Int!
}

type ModifiedResidue {
  coordinate: Int
  dbId: ID!
  displayName: String!
  schemaClass: String!
}

type NegativeGeneExpressionRegulation {
  dbId: ID!
  displayName: String!
  oldStId: String
  schemaClass: String!
  stId: String
  stIdVersion: String
}

type NegativeRegulation {
  dbId: Int!
  displayName: String!
  oldStId: String
  schemaClass: String!
  stId: String
  stIdVersion: String
}

type OtherEntity {
  dbId: ID!
  definition: String
  displayName: String!
  isInDisease: Boolean!
  name: [String]!
  oldStId: String
  schemaClass: String!
  stId: String!
  stIdVersion: String!
}

type Pathway {
  dbId: ID!
  definition: String
  diagramHeight: Int
  diagramWidth: Int
  displayName: String!
  doi: String
  hasDiagram: Boolean!
  hasEHLD: Boolean
  isInDisease: Boolean!
  isInferred: Boolean!
  name: [String]!
  oldStId: String
  releaseDate: String!
  releaseStatus: String
  schemaClass: String!
  speciesName: String!
  stId: String!
  stIdVersion: String!
}

type Person {
  dbId: ID!
  displayName: String!
  firstname: String
  initial: String!
  orcidId: String
  project: String
  schemaClass: String!
  surname: String!
}

type PhysicalEntity {
  dbId: ID!
  definition: String
  displayName: String
  endCoordinate: Int
  isChimeric: Boolean
  isInDisease: Boolean
  isOrdered: Boolean
  maxUnitCount: Int
  minUnitCount: Int
  name: String
  oldStId: String
  referenceType: String
  schemaClass: String
  speciesName: String
  startCoordinate: Int
  stId: String
  stIdVersion: String
  stoichiometryKnown: Boolean
  systematicName: String
}

type Polymer {
  dbId: ID!
  definition: String
  displayName: String!
  isInDisease: Boolean!
  maxUnitCount: Int
  minUnitCount: Int
  name: [String]!
  oldStId: String
  schemaClass: String!
  speciesName: String
  stId: String!
  stIdVersion: String!
}

type Polymerisation {
  dbId: ID!
  displayName: String!
  isChimeric: Boolean
  isInDisease: Boolean!
  isInferred: Boolean!
  name: [String]!
  oldStId: String
  releaseDate: String!
  schemaClass: String!
  speciesName: String!
  stId: String!
  stIdVersion: String!
  systematicName: String
}

type PositiveGeneExpressionRegulation {
  dbId: ID!
  displayName: String!
  oldStId: String
  schemaClass: String!
  stId: String
  stIdVersion: String
}

type PositiveRegulation {
  dbId: Int!
  displayName: String!
  oldStId: String
  schemaClass: String!
  stId: String
  stIdVersion: String
}

type ProteinDrug {
  dbId: ID!
  definition: String
  displayName: String!
  isInDisease: Boolean!
  name: [String]!
  oldStId: String
  schemaClass: String!
  stId: String!
  stIdVersion: String!
}

type PsiMod {
  databaseName: String!
  dbId: ID!
  definition: String
  displayName: String!
  identifier: String!
  label: String
  name: [String]!
  schemaClass: String!
  synonym: [String]
  url: String!
}

type Publication {
  dbId: Int!
  displayName: String!
  ISBN: String
  chapterTitle: String
  journal: String!
  pages: String
  pubMedIdentifier: Int
  schemaClass: String!
  title: String!
  volume: Int
  year: Int!
  uniformResourceLocator: String!
}

type Reaction {
  dbId: Int!
  definition: String
  displayName: String!
  isChimeric: Boolean
  isInDisease: Boolean!
  isInferred: Boolean!
  name: [String]!
  oldStId: String
  releaseDate: String!
  releaseStatus: String
  schemaClass: String!
  speciesName: String!
  stId: String!
  stIdVersion: String!
  systematicName: String
}

type ReactionLikeEvent {
  dbId: Int!
  definition: String
  displayName: String!
  isChimeric: Boolean
  isInDisease: Boolean!
  isInferred: Boolean!
  name: [String]!
  oldStId: String
  releaseDate: String!
  releaseStatus: String
  schemaClass: String!
  speciesName: String!
  stId: String!
  stIdVersion: String!
  systematicName: String
}

type ReferenceDNASequence {
  comment: [String]
  databaseName: String!
  dbId: Int!
  description: [String]
  displayName: String!
  geneName: [String]
  identifier: String!
  keyword: [String]
  name: [String]
  otherIdentifier: [String]
  schemaClass: String!
  sequenceLength: Int
  url: String!
}

type ReferenceDatabase {
  accessUrl: String!
  dbId: Int!
  displayName: String!
  name: [String]!
  schemaClass: String!
  url: String!
}

type ReferenceEntity {
  abbreviation: String
  approvalSource: [String]
  approved: Boolean!
  chain: [String]
  checksum: String
  comment: [String]
  databaseName: String!
  dbId: Int!
  description: [String]
  displayName: String!
  formula: String
  geneName: [String]
  inn: String
  identifier: String!
  isSequenceChanged: Boolean
  keyword: [String]
  name: [String]
  otherIdentifier: [String]
  schemaClass: String!
  secondaryIdentifier: [String]
  sequenceLength: Int
  trivial: Boolean
  type: String
  url: String!
  variantIdentifier: String!
}

type ReferenceGeneProduct {
  chain: [String]
  checksum: String
  comment: [String]
  databaseName: String!
  dbId: Int!
  description: [String]
  displayName: String!
  geneName: [String]
  identifier: String!
  isSequenceChanged: Boolean
  keyword: [String]
  name: [String]
  otherIdentifier: [String]
  schemaClass: String!
  secondaryIdentifier: [String]
  sequenceLength: Int
  url: String!
  variantIdentifier: String!
}

type ReferenceGroup {
  databaseName: String!
  dbId: Int!
  displayName: String!
  formula: String
  identifier: String!
  name: [String]!
  schemaClass: String!
  url: String!
}

type ReferenceIsoform {
  chain: [String]
  checksum: String
  comment: [String]
  databaseName: String!
  dbId: Int!
  description: [String]
  displayName: String!
  geneName: [String]
  identifier: String!
  isSequenceChanged: Boolean
  keyword: [String]
  name: [String]
  otherIdentifier: [String]
  schemaClass: String!
  secondaryIdentifier: [String]
  sequenceLength: Int
  url: String!
  variantIdentifier: String!
}

type ReferenceMolecule {
  databaseName: String!
  dbId: Int!
  displayName: String!
  formula: String
  geneName: [String]
  identifier: String!
  name: [String]!
  otherIdentifier: [String]
  schemaClass: String!
  secondaryIdentifier: [String]
  trivial: Boolean
  url: String!
}

type ReferenceRNASequence {
  comment: [String]
  databaseName: String!
  dbId: Int!
  description: [String]
  displayName: String!
  geneName: [String]
  identifier: String!
  name: [String]
  schemaClass: String!
  url: String!
}

type ReferenceSequence {
  chain: [String]
  checksum: String
  comment: [String]
  databaseName: String!
  dbId: Int!
  description: [String]
  displayName: String!
  geneName: [String]
  identifier: String!
  isSequenceChanged: Boolean
  keyword: [String]
  name: [String]
  otherIdentifier: [String]
  schemaClass: String!
  secondaryIdentifier: [String]
  sequenceLength: Int
  url: String!
  variantIdentifier: String!
}

type ReferenceTherapeutic {
  abbreviation: String
  approvalSource: [String]
  approved: Boolean!
  databaseName: String!
  dbId: Int!
  displayName: String!
  identifier: String!
  inn: String
  name: [String]!
  schemaClass: String!
  type: String
  url: String!
}

type Regulation {
  dbId: Int!
  displayName: String!
  oldStId: String
  schemaClass: String!
  stId: String
  stIdVersion: String
}

type RegulationReference {
  dbId: Int!
  displayName: String!
  schemaClass: String!
}

type ReplacedResidue {
  coordinate: Int!
  dbId: Int!
  displayName: String!
  schemaClass: String!
}

type Requirement {
  dbId: Int!
  displayName: String!
  oldStId: String
  schemaClass: String!
  stId: String
  stIdVersion: String
}

type SequenceOntology {
  databaseName: String!
  dbId: Int!
  definition: String!
  displayName: String!
  identifier: String!
  name: [String]!
  schemaClass: String!
  synonym: [String]!
  url: String!
}

type SimpleEntity {
  dbId: Int!
  definition: String
  displayName: String!
  isInDisease: Boolean!
  name: [String]!
  oldStId: String
  referenceType: String!
  schemaClass: String!
  stId: String!
  stIdVersion: String!
}

type Species {
  abbreviation: String!
  dbId: Int!
  displayName: String!
  name: [String]!
  schemaClass: String!
  taxId: String!
}

type Summation {
  dbId: Int!
  displayName: String!
  schemaClass: String!
  text: String!
}

type Taxon {
  abbreviation: String!
  dbId: Int!
  displayName: String!
  name: [String]!
  schemaClass: String!
  taxId: String!
}

type TopLevelPathway {
  dbId: Int!
  diagramHeight: Int!
  diagramWidth: Int!
  displayName: String!
  doi: String
  hasDiagram: Boolean!
  hasEHLD: Boolean
  isInDisease: Boolean!
  isInferred: Boolean!
  name: [String]!
  oldStId: String
  releaseDate: String!
  releaseStatus: String
  schemaClass: String!
  speciesName: String!
  stId: String!
  stIdVersion: String!
}

type TranslationalModification {
  coordinate: Int
  dbId: Int!
  displayName: String!
  schemaClass: String!
  secondCoordinate: Int
}

type URL {
  dbId: Int!
  displayName: String!
  schemaClass: String!
  title: String!
  uniformResourceLocator: String!
}

type UndirectedInteraction {
  accession: [String]!
  databaseName: String!
  dbId: Int!
  displayName: String!
  pubmed: [String]
  schemaClass: String!
  score: Float!
  url: String!
}

# SAMPLE BUSINESS REVIEW SCHEMA

# type User {
#   id: ID!
#   name: String
#   friends: [User] @relation(name: "FRIENDS", direction: "BOTH")
#   reviews: [Review] @relation(name: "WROTE", direction: "OUT")
#   avgStars: Float
#     @cypher(
#       statement: "MATCH (this)-[:WROTE]->(r:Review) RETURN toFloat(avg(r.stars))"
#     )
#   numReviews: Int
#     @cypher(statement: "MATCH (this)-[:WROTE]->(r:Review) RETURN COUNT(r)")
#   recommendations(first: Int = 3): [Business]
#     @cypher(
#       statement: "MATCH (this)-[:WROTE]->(r:Review)-[:REVIEWS]->(:Business)<-[:REVIEWS]-(:Review)<-[:WROTE]-(:User)-[:WROTE]->(:Review)-[:REVIEWS]->(rec:Business) WHERE NOT EXISTS( (this)-[:WROTE]->(:Review)-[:REVIEWS]->(rec) )WITH rec, COUNT(*) AS num ORDER BY num DESC LIMIT $first RETURN rec"
#     )
# }

# type Business {
#   id: ID!
#   name: String
#   address: String
#   city: String
#   state: String
#   avgStars: Float
#     @cypher(
#       statement: "MATCH (this)<-[:REVIEWS]-(r:Review) RETURN coalesce(avg(r.stars),0.0)"
#     )
#   reviews: [Review] @relation(name: "REVIEWS", direction: "IN")
#   categories: [Category] @relation(name: "IN_CATEGORY", direction: "OUT")
# }

# type Review {
#   id: ID!
#   stars: Int
#   text: String
#   date: Date
#   business: Business @relation(name: "REVIEWS", direction: "OUT")
#   user: User @relation(name: "WROTE", direction: "IN")
# }

# type Category {
#   name: ID!
#   businesses: [Business] @relation(name: "IN_CATEGORY", direction: "IN")
# }

# type Query {
#   usersBySubstring(substring: String): [User]
#     @cypher(
#       statement: "MATCH (u:User) WHERE u.name CONTAINS $substring RETURN u"
#     )
# }
